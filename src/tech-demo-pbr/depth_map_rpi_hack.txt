
reference: http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
I added the test 

vec4 encodeRGBA(float f) {
    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * f;
    enc = fract(enc);
    //enc -= enc.yzww * vec4(1. / 255., 1. / 255., 1. / 255., 0.);
    enc -= enc.yzww * vec4(3.9215686275e-03, 3.9215686275e-03, 3.9215686275e-03, 0.0);
    float f_ge_1 = f >= 9.9999993969e-01;//step(9.9999993969e-01, f)
    //enc = mix(enc,vec4(254.0 / 255.0), f_ge_1);
    enc = mix(enc,vec4(9.9607843137e-01), f_ge_1);
    return enc;
}

float decodeRGBA(vec4 v) {
    //return dot(v, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
    return dot(v, vec4(1.0, 3.9215686275e-03, 1.5378700500e-05, 6.0308629411e-08));
}

printf("1.0 / 255.0 = %.10e\n", 1.0 / 255.0);
printf("1.0 / 65025.0 = %.10e\n", 1.0 / 65025.0);
printf("1.0 / 16581375.0 = %.10e\n", 1.0 / 16581375.0);
printf("254.0 / 255.0 = %.10e\n", 254.0 / 255.0);
printf("1.0 - 1.0 / 16581375.0 = %.10e\n", 1.0 - 1.0 / 16581375.0);
/*
1.0 / 255.0 = 3.9215686275e-03
1.0 / 65025.0 = 1.5378700500e-05
1.0 / 16581375.0 = 6.0308629411e-08
254.0 / 255.0 = 9.9607843137e-01
1.0 - 1.0 / 16581375.0 = 9.9999993969e-01
*/
